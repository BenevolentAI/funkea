
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>SNPsea &#8212; funkea 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="LDSC" href="implementations.ldsc.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-funkea.implementations.snpsea">
<span id="snpsea"></span><h1>SNPsea<a class="headerlink" href="#module-funkea.implementations.snpsea" title="Permalink to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.BackgroundVariants">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">BackgroundVariants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">DataFrame</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.BackgroundVariants" title="Permalink to this definition">¶</a></dt>
<dd><p>A component that loads background variants.</p>
<p>This component loads background variants from a dataset. The dataset is used to determine the
significance of the observed overlap between variants and annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dataset</strong> – The dataset to load background variants from.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.BinarySpecificity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">BinarySpecificity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locus_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.BinarySpecificity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute specificity scores for binary annotations (i.e. hard partitions).</p>
<p>The specificity score is computed as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}K_{il} =
\begin{cases}
    1 - \frac{{|\mathcal{G}| - n_i \choose c_l}}{{|\mathcal{G}| \choose c_l}} &amp; \text{if } \sum_j^{|\mathcal{G}|} X_{ij} L_{jl} \, &gt; 0 \\
    1 &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(n_i = \sum_j^{|\mathcal{G}|} X_{ij}\)</span> (the number of annotations in a given
partition <span class="math notranslate nohighlight">\(i\)</span>). The binomial coefficient is computed using the log-gamma function
<span class="math notranslate nohighlight">\(\log \Gamma(x) = \log((x - 1)!)\)</span>. This is done to avoid overflow when computing the
binomial coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locus_id_col</strong> – The name of the locus ID column.</p></li>
<li><p><strong>partition_id_col</strong> – The name of the partition ID column.</p></li>
<li><p><strong>annotation_id_col</strong> – The name of the annotation ID column.</p></li>
<li><p><strong>values_col</strong> – The name of the values column.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.CollectExpandedIfEmpty">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">CollectExpandedIfEmpty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extension</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">pydantic.types.NonNegativeInt</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">pydantic.types.NonNegativeInt</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="core.data.html#funkea.core.data.AnnotationComponent" title="funkea.core.data.AnnotationComponent"><span class="pre">AnnotationComponent</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.CollectExpandedIfEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects annotations from expanded locus if locus does not overlap with any annotation.</p>
<p>This transform is similar to <a class="reference internal" href="components.locus_definition.html#funkea.components.locus_definition.Collect" title="funkea.components.locus_definition.Collect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Collect</span></code></a>, but collects annotations from the expanded locus
if the locus does not overlap with any annotation. This is useful for methods that require at
least one annotation per locus, such as <a class="reference internal" href="#funkea.implementations.snpsea.SNPsea" title="funkea.implementations.snpsea.SNPsea"><code class="xref py py-class docutils literal notranslate"><span class="pre">SNPsea</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>extension</strong> – The number of base pairs to extend the locus by.</p></li>
<li><p><strong>annotation</strong> – The annotation component to collect annotations from.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">annotation</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>RuntimeError</strong> – If either <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">end</span></code> is missing from the input dataframe.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.ContinuousSpecificity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">ContinuousSpecificity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locus_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.ContinuousSpecificity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute specificity scores for continuous annotations (i.e. soft partitions).</p>
<p>The specificity score is computed as the Bonferroni-corrected minimum value of the annotations
in a locus:</p>
<div class="math notranslate nohighlight">
\[\begin{split}K_{il} &amp;= 1 - \left(1 - \langle \bar{\mathbf{X}}_i, \mathbf{L}_l \rangle \right) ^ {c_l} \\
\langle \bar{\mathbf{X}}_{i}, \mathbf{L}_{l} \rangle &amp;:= \min_j \bar{X}_{ij} ^ {L_{jl}} \\
c_l &amp;= \sum_j^{|\mathcal{G}|} L_{jl}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{\mathbf{X}} \in \mathbb{R} ^ {K \times |\mathcal{G}|}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{L} \in \{0, 1\} ^ {|\mathcal{G}| \times M}\)</span> are the (normalised) annotation and
locus matrices, respectively, and <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> is the set of all possible annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locus_id_col</strong> – The name of the locus ID column.</p></li>
<li><p><strong>partition_id_col</strong> – The name of the partition ID column.</p></li>
<li><p><strong>annotation_id_col</strong> – The name of the annotation ID column.</p></li>
<li><p><strong>values_col</strong> – The name of the values column.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.Method">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">Method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">partition_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="core.data.html#funkea.core.data.PartitionType" title="funkea.core.data.PartitionType"><span class="pre">PartitionType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">locus_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'locus_id'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'score'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locus_type_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'locus_type'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permutations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NonNegativeInt</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.Method" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute specificity scores for SNPsea.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>partition_id_col</strong> – The name of the partition ID column.</p></li>
<li><p><strong>annotation_id_col</strong> – The name of the annotation ID column.</p></li>
<li><p><strong>partition_type</strong> – The type of partition.</p></li>
<li><p><strong>locus_id_col</strong> – The name of the locus ID column.</p></li>
<li><p><strong>score_col</strong> – The name of the score column. Defaults to “score”. Score here refers to the
to the annotation-partition value.</p></li>
<li><p><strong>locus_type_col</strong> – The name of the locus type column. Defaults to “locus_type”. Locus type
refers to the type of locus (e.g. “true”, “null”).</p></li>
<li><p><strong>n_permutations</strong> – The number of permutations to perform. Defaults to 500. Sets the number of
permutations to perform when computing the empirical p-value. Higher values will
increase the accuracy of the p-value, but will also increase the computation time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.Params">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">Params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expansion_window</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NonNegativeInt</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expansion_r2_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="core.utils.types.html#funkea.core.utils.types.UnitFloat" title="funkea.core.utils.types.UnitFloat"><span class="pre">UnitFloat</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">association_threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="core.utils.types.html#funkea.core.utils.types.UnitFloat" title="funkea.core.utils.types.UnitFloat"><span class="pre">UnitFloat</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permutations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NonNegativeInt</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for SNPsea.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expansion_window</strong> – The window size to use when expanding the locus set. Defaults to 10,000.
This is the number of base pairs to expand the locus set by in each direction. If the
locus does not contain any annotations, then the locus will be expanded once more.</p></li>
<li><p><strong>expansion_r2_threshold</strong> – The R2 threshold to use when expanding the locus set. Defaults to
0.5. This is the R2 threshold to use when expanding the locus set, i.e. the minimum
R2 value between the lead variant and the variants in the locus set.</p></li>
<li><p><strong>association_threshold</strong> – The association threshold to use when selecting the lead variants.
Defaults to <span class="math notranslate nohighlight">\(5e-8\)</span>.</p></li>
<li><p><strong>n_permutations</strong> – The number of permutations to perform. Defaults to 500. Sets the number of
permutations to perform when computing the empirical p-value. Higher values will
increase the accuracy of the p-value, but will also increase the computation time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.PercentileAssignment">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">PercentileAssignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_by</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">('id',)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.PercentileAssignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns percentiles to a column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_col</strong> – The column to assign percentiles to.</p></li>
<li><p><strong>output_col</strong> – The column to store the percentiles in.</p></li>
<li><p><strong>partition_by</strong> – The columns to partition by. Percentiles are assigned within each partition.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.Pipeline">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">Pipeline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locus_definition:</span> <span class="pre">~funkea.components.locus_definition.LocusDefinition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variant_selector:</span> <span class="pre">funkea.components.variant_selection.VariantSelection</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_variants:</span> <span class="pre">~funkea.implementations.snpsea.BackgroundVariants</span> <span class="pre">=</span> <span class="pre">&lt;funkea.implementations.snpsea.BackgroundVariants</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_permutations:</span> <span class="pre">~pydantic.types.NonNegativeInt</span> <span class="pre">=</span> <span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact_match_cutoff:</span> <span class="pre">~pydantic.types.NonNegativeInt</span> <span class="pre">=</span> <span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.Pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>A data pipeline for SNPsea.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>locus_definition</strong> – The locus definition component.</p></li>
<li><p><strong>variant_selector</strong> – The variant selection component.</p></li>
<li><p><strong>background_variants</strong> – The background variants component. The background variants are used to
determine the significance of the observed overlap between variants and annotations.</p></li>
<li><p><strong>n_permutations</strong> – The number of permutations to perform. The default is 500. Increasing this
number will increase the accuracy of the p-values, but will also increase the runtime.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.Pipeline.get_matched_null_loci">
<span class="sig-name descname"><span class="pre">get_matched_null_loci</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loci</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">DataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="headerlink" href="#funkea.implementations.snpsea.Pipeline.get_matched_null_loci" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the null loci that match the given loci.</p>
<p>Matching is performed by matching the number of annotations in each locus. The null loci are
matched exactly if the number of annotations in the locus is less than or equal to the
<cite>exact_match_cutoff</cite>. Otherwise, the null loci are matched by sampling from the null loci
with the closest number of annotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>loci</strong> – The loci to match null loci to.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.SNPsea">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">SNPsea</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pipeline</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Pipeline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.SNPsea" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes functional enrichment using <code class="docutils literal notranslate"><span class="pre">SNPsea</span></code>.</p>
<p>Originally developed for tissue and cell-type enrichment <a class="footnote-reference brackets" href="#id8" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id9" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, <code class="docutils literal notranslate"><span class="pre">SNPsea</span></code> has also been
applied to pathway enrichment <a class="footnote-reference brackets" href="#id9" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>. It uses activity matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> to allow for
definitions of “soft” partitions; that is, distributing each annotation over the <span class="math notranslate nohighlight">\(K\)</span>
partitions. For example, in tissue enrichment <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> may be a gene expression
matrix such that <span class="math notranslate nohighlight">\(X_{ij}\)</span> is the expression of gene <span class="math notranslate nohighlight">\(j\)</span> in tissue <span class="math notranslate nohighlight">\(i\)</span>. A nice
property of this method, is that it is defined both for
<span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{K \times |G|}\)</span> and
<span class="math notranslate nohighlight">\(\mathbf{X} \in \{0, 1\}^{K \times |G|}\)</span>, i.e. it works for soft <em>and</em> hard partitions.
If <span class="math notranslate nohighlight">\(\mathbf{X} \in \mathbb{R}^{K \times |\mathcal{G}|}\)</span>, then it is normalised in the
following way:</p>
<div class="math notranslate nohighlight">
\[\bar{\mathbf{X}} = (h \circ g \circ f)(\mathbf{X})\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}f &amp;:= \texttt{quantile_norm} \label{eqn:f} \\
g &amp;:= \texttt{euclid_norm} \label{eqn:g} \\
h &amp;:= \texttt{percentile_assignment} \label{eqn:h}\end{split}\]</div>
<p>eqref{eqn:g} is the easiest to explain mathematically, and simply normalises each column
vector in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> to unit length; that is, each annotation <span class="math notranslate nohighlight">\(j\)</span> will have
length 1 over all <span class="math notranslate nohighlight">\(K\)</span> partitions. In the example of gene expression, this amplifies
specifically expressed genes and surpresses ubiquitously expressed ones. To better understand
eqref{eqn:f}, consider the following code snippet:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">quantile_norm</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="gp">... </span>   <span class="c1"># subtract 1 to get 0-based indexes</span>
<span class="gp">... </span>   <span class="n">rank</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="n">rank</span><span class="p">]</span>
</pre></div>
</div>
<p>i.e. we average the <em>observed</em> quantiles in each partition over the <span class="math notranslate nohighlight">\(K\)</span> partitions and
then assign each annotation in each partition to a quantile. See <a class="footnote-reference brackets" href="#id10" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#id11" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> for a reference.</p>
<p>Similarly, eqref{eqn:h} assigns <span class="math notranslate nohighlight">\(1\)</span> minus the percentile of each annotation in a given
partition to that annotation, such that the final activity matrix
<span class="math notranslate nohighlight">\(\bar{\mathbf{X}} \in \left[ \frac{1}{|\mathcal{G}|}, 1 \right]^{K \times |\mathcal{G}|}\)</span>.
It is important to emphasise that this means that <em>higher</em> values in <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> will be
assigned to <em>lower</em> values in <span class="math notranslate nohighlight">\(\bar{\mathbf{X}}\)</span>.</p>
<p>Next, <code class="docutils literal notranslate"><span class="pre">SNPsea</span></code> defines a locus as the sequence span covered by the furthest LD proxies of a
genome-wide significant variant. These loci are then linked to annotations by overlapping the
locus spans with the annotation spans. If a locus does not overlap any annotations, it will be
expanded by :math:<a href="#id6"><span class="problematic" id="id7">`</span></a>10`kb on either side and overlap will be attempted again. Loci which overlap
the same annotations are combined into a single locus.</p>
<p>These annotation-locus links can be represented in a bipartite adjacency matrix
<span class="math notranslate nohighlight">\(\mathbf{L} \in \{0, 1\}^{|\mathcal{G}| \times M}\)</span>, where <span class="math notranslate nohighlight">\(M\)</span> specifies the number
of loci in the study. Using this and <span class="math notranslate nohighlight">\(\bar{\mathbf{X}}\)</span>, we can compute the
partition-locus specificity score matrix <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>, where <span class="math notranslate nohighlight">\(K_{il}\)</span> between
partition <span class="math notranslate nohighlight">\(i\)</span> and locus <span class="math notranslate nohighlight">\(l\)</span> is defines as:</p>
<div class="math notranslate nohighlight">
\[K_{il} = 1 - \left(1 - \langle \bar{\mathbf{X}}_i, \mathbf{L}_l \rangle \right) ^ {c_l}\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{\mathbf{X}}_i\)</span> is the normalised activity profile for partition <span class="math notranslate nohighlight">\(i\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{L}_l\)</span> is the adjacency vector for locus <span class="math notranslate nohighlight">\(l\)</span> and</p>
<div class="math notranslate nohighlight">
\[c_l = \sum_j^{|\mathcal{G}|} L_{jl}\]</div>
<p>is the total number of annotations in locus <span class="math notranslate nohighlight">\(l\)</span>. Finally, the inner product between
<span class="math notranslate nohighlight">\(\mathbf{X}_i\)</span> and <span class="math notranslate nohighlight">\(\mathbf{L}_l\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[\langle \bar{\mathbf{X}}_{i}, \mathbf{L}_{l} \rangle := \min_j \bar{X}_{ij} ^ {L_{jl}}\]</div>
<p>Since <span class="math notranslate nohighlight">\(L_{kl} \in \{0, 1\}\)</span> and <span class="math notranslate nohighlight">\(\bar{X}_{ik} \in [\frac{1}{D}, 1]\)</span>, the above
inner product will always return the highest specificity value in a locus. Remember that a low
value in <span class="math notranslate nohighlight">\(\bar{\mathbf{X}}\)</span> (percentile), denotes high specificity.</p>
<p>The enrichment <span class="math notranslate nohighlight">\(e_i\)</span> for partition <span class="math notranslate nohighlight">\(i\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[e_i = - \sum_l^{M} \log (K_{il})\]</div>
<p>In the case when <span class="math notranslate nohighlight">\(\mathbf{X} \in \{0, 1\}^{|\mathcal{G}| \times M}\)</span>, the specificity score
matrix <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is computed in the following way:</p>
<div class="math notranslate nohighlight">
\[\begin{split}K_{il} =
\begin{cases}
    1 - \frac{{|\mathcal{G}| - n_i \choose c_l}}{{|\mathcal{G}| \choose c_l}} &amp; \text{if } \sum_j^{|\mathcal{G}|} X_{ij} L_{jl} \, &gt; 0 \\
    1 &amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(n_i = \sum_j^{|\mathcal{G}|} X_{ij}\)</span>.</p>
<p>The significance of <span class="math notranslate nohighlight">\(e_i\)</span> is then computed via a permutation-based test. First, a set of
“null” loci are generated from a list of LD pruned, non-associated variants. Then, a set of null
loci are sampled, such that each true locus has a null counterpart, which contains (roughly) the
same number of annotations (i.e. <span class="math notranslate nohighlight">\(c_l \approx c_{\tilde{l}}\)</span>). From these null loci, a
null enrichment <span class="math notranslate nohighlight">\(\tilde{e}_{ik}\)</span> is computed. These steps are repeated <span class="math notranslate nohighlight">\(N\)</span> times,
giving us the <span class="math notranslate nohighlight">\(p\)</span>-value for enrichment <span class="math notranslate nohighlight">\(e_i\)</span>, like so:</p>
<div class="math notranslate nohighlight">
\[p_i = \frac{1}{N} \sum_k^N \mathbb{1} \left[ e_i \leq \tilde{e}_{ik} \right]\]</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Hu, X., Kim, H., Stahl, E., Plenge, R., Daly, M. and Raychaudhuri, S., 2011.
Integrating autoimmune risk loci with gene-expression data identifies specific
pathogenic immune cell subsets. The American Journal of Human Genetics, 89(4),
pp.496-506.</p>
</aside>
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p>Slowikowski, K., Hu, X. and Raychaudhuri, S., 2014. SNPsea: an algorithm to identify
cell types, tissues and pathways affected by risk loci. Bioinformatics, 30(17),
pp.2496-2497.</p>
</aside>
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>Amaratunga, D. and Cabrera, J., 2001. Analysis of data from viral DNA microchips.
Journal of the American Statistical Association, 96(456), pp.1161-1170.</p>
</aside>
<aside class="footnote brackets" id="id11" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p>Bolstad, B.M., Irizarry, R.A., Åstrand, M. and Speed, T.P., 2003. A comparison of
normalization methods for high density oligonucleotide array data based on variance and
bias. Bioinformatics, 19(2), pp.185-193.</p>
</aside>
</aside>
<dl class="py method">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.SNPsea.default">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">annotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="core.data.html#funkea.core.data.AnnotationComponent" title="funkea.core.data.AnnotationComponent"><span class="pre">AnnotationComponent</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#funkea.implementations.snpsea.Params" title="funkea.implementations.snpsea.Params"><span class="pre">Params</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">Params(expansion_window=10000,</span> <span class="pre">expansion_r2_threshold=0.5,</span> <span class="pre">association_threshold=5e-08,</span> <span class="pre">n_permutations=500)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Self</span></span></span><a class="headerlink" href="#funkea.implementations.snpsea.SNPsea.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a default instance of this workflow.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>annotation</strong> – The annotation component to use. If not specified, a default annotation
component will be used (GTEx).</p></li>
<li><p><strong>params</strong> – The parameters to use for this workflow.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="funkea.implementations.snpsea.SpecificityScore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">funkea.implementations.snpsea.</span></span><span class="sig-name descname"><span class="pre">SpecificityScore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">locus_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotation_id_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#funkea.implementations.snpsea.SpecificityScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for specificity scores.</p>
<p>This class is not meant to be used directly. Instead, use one of the subclasses. Specificity
scores are computed for each locus and partition combination.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">funkea</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="components.html">funkea.components</a></li>
<li class="toctree-l2"><a class="reference internal" href="core.html">funkea.core</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="implementations.html">funkea.implementations</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">funkea API</a><ul>
  <li><a href="implementations.html">Implementations</a><ul>
      <li>Previous: <a href="implementations.ldsc.html" title="previous chapter">LDSC</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023-2023, Benjamin Tenmann.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/reference/implementations.snpsea.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>